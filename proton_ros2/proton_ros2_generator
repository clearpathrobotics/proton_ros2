#!/usr/bin/env python3

# Software License Agreement (BSD)
#
# @author    Roni Kreinin <rkreinin@clearpathrobotics.com>
# @copyright (c) 2025, Clearpath Robotics, Inc., All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of Clearpath Robotics nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import argparse
import os
import yaml

from typing import List

from proton_ros2.message_config import ProtonROS2Config
from proton_ros2.source_writer import CPPWriter, Function, Variable
from proton_ros2.flatten import get_package_config


class ProtonROS2AdapterGenerator:
    SignalMap = {
        "double": "double",
        "float": "float",
        "int32": "int32_t",
        "int64": "int64_t",
        "uint32": "uint32_t",
        "uint64": "uint64_t",
        "bool": "bool",
        "string": "std::string",
        "bytes": "proton::bytes",
        "list_double": "proton::list_double",
        "list_float": "proton::list_float",
        "list_int32": "proton::list_int32",
        "list_int64": "proton::list_int64",
        "list_uint32": "proton::list_uint32",
        "list_uint64": "proton::list_uint64",
        "list_bool": "proton::list_bool",
        "list_string": "proton::list_string",
        "list_bytes": "proton::list_bytes",
    }

    ListSignalMap = {
        "bytes": "uint8_t",
        "list_double": "double",
        "list_float": "float",
        "list_int32": "int32_t",
        "list_int64": "int64_t",
        "list_uint32": "uint32_t",
        "list_uint64": "uint64_t",
        "list_bool": "bool",
        "list_string": "std::string",
        "list_bytes": "proton::bytes",
    }

    PROTON_ROS2 = "proton_ros2"
    MESSAGES = "messages"
    SERVICES = "services"

    def __init__(self, config: dict, destination_header: str, destination_source: str, is_message: bool=True):
        if is_message:
            self.header_path = os.path.join(destination_header, self.MESSAGES)
            self.source_path = os.path.join(destination_source, self.MESSAGES)
        else:
            self.header_path = os.path.join(destination_header, self.SERVICES)
            self.source_path = os.path.join(destination_source, self.SERVICES)
        self.is_message = is_message
        if not os.path.exists(self.header_path):
            os.mkdir(self.header_path)
        if not os.path.exists(self.source_path):
            os.mkdir(self.source_path)

        self.dictionary = config
        self.config = ProtonROS2Config(self.dictionary)

        if is_message:
            self.generated_header_name = f"{self.config.package}_msg.hpp"
            self.generated_include = f"{self.PROTON_ROS2}/{self.MESSAGES}/{self.generated_header_name}"
            self.generated_source_name = f"{self.config.package}_msg.cpp"
        else:
            self.generated_header_name = f"{self.config.package}_srv.hpp"
            self.generated_include = f"{self.PROTON_ROS2}/{self.SERVICES}/{self.generated_header_name}"
            self.generated_source_name = f"{self.config.package}_srv.cpp"

    def read_yaml(self):
        # Check YAML can be Opened
        try:
            config = yaml.load(open(self.config_file), Loader=yaml.SafeLoader)
        except yaml.scanner.ScannerError:
            raise AssertionError(f'YAML file "{self.config_file}" is not well formed')
        except yaml.constructor.ConstructorError:
            raise AssertionError(
                f'YAML file "{self.config_file}" is attempting to create unsafe objects'
            )
        # Check contents are a Dictionary
        assert isinstance(config, dict), (
            f'YAML file "{self.config_file}" is not a dictionary'
        )
        return config

    def generate_mapping_to_ros(self, map: ProtonROS2Config.Mapping):
        self.source_writer.write(
            f'if (source.hasSignal("{map.proton_signal}")) {{', indent_level=1
        )

        match(map.mapping_type):
            case ProtonROS2Config.Mapping.MappingType.SCALAR:
                self.source_writer.write(
                  f'destination.{map.ros_path} = source.getConstSignal("{map.proton_signal}").getValue<{self.SignalMap[map.data_type]}>();',
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.PROTON_INDEXED:
                self.source_writer.write(
                  f'destination.{map.ros_path} = source.getConstSignal("{map.proton_signal}").getValue<{self.SignalMap[map.data_type]}>().at({map.proton_index});',
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.ROS_INDEXED:
                self.source_writer.write(
                  f'destination.{map.ros_path}.at({map.ros_index}) = source.getConstSignal("{map.proton_signal}").getValue<{self.SignalMap[map.data_type]}>();',
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.BOTH_INDEXED:
                self.source_writer.write(
                  f'destination.{map.ros_path}.at({map.ros_index}) = source.getConstSignal("{map.proton_signal}").getValue<{self.SignalMap[map.data_type]}>().at({map.proton_index});',
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.FIXED_LIST:
                # Get signal list length
                if map.data_type == "bytes":
                    self.source_writer.write(
                      f'std::size_t len = source.getConstSignal("{map.proton_signal}").getCapacity();',
                      indent_level=2,
                    )
                else:
                    self.source_writer.write(
                      f'std::size_t len = source.getConstSignal("{map.proton_signal}").getLength();',
                      indent_level=2,
                    )
                # Limit array size to the minimum of the ROS array length, and the signal length
                self.source_writer.write(
                  f"int n = std::min(len, destination.{map.ros_path}.size());",
                  indent_level=2,
                )
                # Copy proton list to ROS array
                self.source_writer.write(f"auto {map.proton_signal} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.SignalMap[map.data_type]}>();", indent_level=2)
                self.source_writer.write(
                  f"std::copy({map.proton_signal}.begin(), {map.proton_signal}.begin() + n, destination.{map.ros_path}.begin());",
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.DYNAMIC_LIST:
                # Copy proton list to ROS vector
                self.source_writer.write(f"destination.{map.ros_path} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.SignalMap[map.data_type]}>();", indent_level=2)
            case (ProtonROS2Config.Mapping.MappingType.FIXED_SUBMESSAGE | ProtonROS2Config.Mapping.MappingType.DYNAMIC_SUBMESSAGE):
                # Get signal value
                self.source_writer.write(f"{self.SignalMap[map.data_type]} {map.proton_signal} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.SignalMap[map.data_type]}>();", indent_level=2)
                # Limit array size to the minimum of the ROS array length, and the signal length
                self.source_writer.write(
                  f"int n = std::min({map.proton_signal}.size(), destination.{map.ros_path}.size());",
                  indent_level=2,
                )
                if map.mapping_type == ProtonROS2Config.Mapping.MappingType.DYNAMIC_SUBMESSAGE:
                    # Resize ROS array to n
                    self.source_writer.write(
                      f"destination.{map.ros_path}.resize(n);",
                      indent_level=2,
                    )
                # Copy proton list to ROS array

                self.source_writer.write_for_loop_start("n",indent_level=2)
                self.source_writer.write(f"destination.{map.ros_path}.at(i).{map.ros_subpath} = {map.proton_signal}.at(i);", indent_level=3)
                self.source_writer.write_for_loop_end(indent_level=2)
            case (ProtonROS2Config.Mapping.MappingType.FIXED_SUBINDEX | ProtonROS2Config.Mapping.MappingType.DYNAMIC_SUBINDEX):
                # Get signal value
                self.source_writer.write(f"{self.SignalMap[map.data_type]} {map.proton_signal} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.SignalMap[map.data_type]}>();", indent_level=2)
                if map.mapping_type == ProtonROS2Config.Mapping.MappingType.DYNAMIC_SUBINDEX:
                    # Resize ROS array to n
                    self.source_writer.write(
                      f"destination.{map.ros_path}.resize({map.proton_signal}.size());",
                      indent_level=2,
                    )
                # Copy proton subindex to ROS subpath
                self.source_writer.write_for_loop_start(f"static_cast<int>({map.proton_signal}.size())",indent_level=2)
                self.source_writer.write(f"destination.{map.ros_path}.at(i).{map.ros_subpath} = {map.proton_signal}.at(i).at({map.proton_subindex});", indent_level=3)
                self.source_writer.write_for_loop_end(indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)

    def generate_mapping_to_bundle(self, map: ProtonROS2Config.Mapping):
        self.source_writer.write(
            f'if (destination.hasSignal("{map.proton_signal}")) {{', indent_level=1
        )

        match(map.mapping_type):
            case ProtonROS2Config.Mapping.MappingType.SCALAR:
                self.source_writer.write(
                  f'destination.getSignal("{map.proton_signal}").setValue<{self.SignalMap[map.data_type]}>(source.{map.ros_path});',
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.PROTON_INDEXED:
                self.source_writer.write(
                  f'destination.getSignal("{map.proton_signal}").setValue<{self.ListSignalMap[map.data_type]}>({map.proton_index}, source.{map.ros_path});',
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.ROS_INDEXED:
                self.source_writer.write(
                  f'destination.getSignal("{map.proton_signal}").setValue<{self.SignalMap[map.data_type]}>(source.{map.ros_path}.at({map.ros_index}));',
                  indent_level=2,
                )
            case ProtonROS2Config.Mapping.MappingType.BOTH_INDEXED:
                self.source_writer.write(
                  f'destination.getSignal("{map.proton_signal}").setValue<{self.ListSignalMap[map.data_type]}>({map.proton_index}, source.{map.ros_path}.at({map.ros_index}));',
                  indent_level=2,
                )
            case (ProtonROS2Config.Mapping.MappingType.FIXED_LIST | ProtonROS2Config.Mapping.MappingType.DYNAMIC_LIST):
                # Get signal list length
                if map.data_type == "bytes":
                    self.source_writer.write(
                      f'std::size_t len = destination.getSignal("{map.proton_signal}").getCapacity();',
                      indent_level=2,
                    )
                else:
                    self.source_writer.write(
                      f'std::size_t len = destination.getSignal("{map.proton_signal}").getLength();',
                      indent_level=2,
                    )
                # Limit array size to the minimum of the ROS array length, and the signal length
                self.source_writer.write(
                  f"int n = std::min(len, source.{map.ros_path}.size());",
                  indent_level=2,
                )
                # Create proton list type of n length
                self.source_writer.write(
                  f"{self.SignalMap[map.data_type]} {map.proton_signal}(n);",
                  indent_level=2,
                )
                # Copy ROS array into proton list
                self.source_writer.write(
                  f"std::copy(source.{map.ros_path}.begin(), source.{map.ros_path}.begin() + n, {map.proton_signal}.begin());",
                  indent_level=2,
                )
                # Set value
                self.source_writer.write(
                  f'destination.getSignal("{map.proton_signal}").setValue<{self.SignalMap[map.data_type]}>({map.proton_signal});',
                  indent_level=2,
                )
            case (ProtonROS2Config.Mapping.MappingType.FIXED_SUBMESSAGE | ProtonROS2Config.Mapping.MappingType.DYNAMIC_SUBMESSAGE):
                # Get signal list length
                if map.data_type == "bytes":
                    self.source_writer.write(
                      f'std::size_t len = destination.getSignal("{map.proton_signal}").getCapacity();',
                      indent_level=2,
                    )
                else:
                    self.source_writer.write(
                      f'std::size_t len = destination.getSignal("{map.proton_signal}").getLength();',
                      indent_level=2,
                    )
                # Limit array size to the minimum of the ROS array length, and the signal length
                self.source_writer.write(
                  f"int n = std::min(len, source.{map.ros_path}.size());",
                  indent_level=2,
                )
                # Create proton list type of n length
                self.source_writer.write(
                  f"{self.SignalMap[map.data_type]} {map.proton_signal}(n);",
                  indent_level=2,
                )
                self.source_writer.write_for_loop_start("n",indent_level=2)
                self.source_writer.write(f"destination.getSignal(\"{map.proton_signal}\").setValue<{self.ListSignalMap[map.data_type]}>(i, source.{map.ros_path}.at(i).{map.ros_subpath});", indent_level=3)
                self.source_writer.write_for_loop_end(indent_level=2)
            case (ProtonROS2Config.Mapping.MappingType.FIXED_SUBINDEX | ProtonROS2Config.Mapping.MappingType.DYNAMIC_SUBINDEX):
                # Limit array size to the minimum of the ROS array length, and the signal length
                self.source_writer.write(
                  f'int n = std::min(static_cast<std::size_t>(destination.getSignal("{map.proton_signal}").getLength()), source.{map.ros_path}.size());',
                  indent_level=2,
                )
                # Create proton list type of n length
                self.source_writer.write(
                  f"{self.SignalMap[map.data_type]} {map.proton_signal}(n);",
                  indent_level=2,
                )
                # Iterate through each index, assign value to subindex
                self.source_writer.write_for_loop_start("n",indent_level=2)
                self.source_writer.write(f"destination.getSignal(\"{map.proton_signal}\").setValue<uint8_t>(i, {map.proton_subindex}, source.{map.ros_path}.at(i).{map.ros_subpath});", indent_level=3)
                self.source_writer.write_for_loop_end(indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)

    def generate_message_type_adapter(self, config: ProtonROS2Config.Message):
        self.header_writer.write("template<>", indent_level=0)
        self.header_writer.write(
            f"struct rclcpp::TypeAdapter<proton::BundleHandle, {config.ros_type}> {{",
            indent_level=0,
        )
        self.header_writer.write(
            "using is_specialized = std::true_type;", indent_level=1
        )
        self.header_writer.write(
            "using custom_type = proton::BundleHandle;", indent_level=1
        )
        self.header_writer.write(
            f"using ros_message_type = {config.ros_type};", indent_level=1
        )
        self.header_writer.write_newline()

        to_ros = Function("convert_to_ros_message",
                          [Variable("source", "const custom_type &"),
                           Variable("destination", "ros_message_type &")],
                          "static void")

        to_custom = Function("convert_to_custom",
                          [Variable("source", "const ros_message_type &"),
                           Variable("destination", "custom_type &")],
                          "static void")

        self.header_writer.write_function_prototype(to_ros, indent_level=1)
        self.header_writer.write_function_prototype(to_custom, indent_level=1)
        self.header_writer.write("};", indent_level=0)

        # Convert to ROS
        self.source_writer.write(f"void rclcpp::TypeAdapter<proton::BundleHandle, {config.ros_type}>::convert_to_ros_message(const custom_type & source, ros_message_type & destination) {{", indent_level=0)
        if config.stamp:
            self.source_writer.write(
                f"destination.{config.stamp} = proton::ros2::Utils::getTimeStamp();",
                indent_level=1,
            )

        if len(config.mappings) == 0:
            self.source_writer.write("RCL_UNUSED(source);")
            self.source_writer.write("RCL_UNUSED(destination);")
        else:
            for map in config.mappings:
                self.generate_mapping_to_ros(map)

        self.source_writer.write_function_end()

        # Convert to Custom
        self.source_writer.write(f"void rclcpp::TypeAdapter<proton::BundleHandle, {config.ros_type}>::convert_to_custom(const ros_message_type & source, custom_type & destination) {{", indent_level=0)

        if len(config.mappings) == 0:
            self.source_writer.write("RCL_UNUSED(source);")
            self.source_writer.write("RCL_UNUSED(destination);")
        else:
            for map in config.mappings:
                self.generate_mapping_to_bundle(map)

        self.source_writer.write_function_end()

    def generate_service_type_adapter(self, config: ProtonROS2Config.Service):
        self.header_writer.write("template<>", indent_level=0)
        self.header_writer.write(
            f"struct ServiceTypeAdapter<{config.ros_type}> {{",
            indent_level=0,
        )
        self.header_writer.write(
            f"using RequestROS = typename {config.ros_type}::Request;", indent_level=1
        )
        self.header_writer.write(
            f"using ResponseROS = typename {config.ros_type}::Response;", indent_level=1
        )
        self.header_writer.write_newline()

        to_ros_request = Function("convert_to_ros",
                          [Variable("source", "const proton::BundleHandle &"),
                           Variable("destination", "RequestROS &")],
                          "static void")

        to_ros_response = Function("convert_to_ros",
                          [Variable("source", "const proton::BundleHandle &"),
                           Variable("destination", "ResponseROS &")],
                          "static void")

        to_bundle_request = Function("convert_to_bundle",
                          [Variable("source", "const RequestROS &"),
                           Variable("destination", "proton::BundleHandle &")],
                          "static void")

        to_bundle_response = Function("convert_to_bundle",
                          [Variable("source", "const ResponseROS &"),
                           Variable("destination", "proton::BundleHandle &")],
                          "static void")

        self.header_writer.write_function_prototype(to_ros_request, indent_level=1)
        self.header_writer.write_function_prototype(to_ros_response, indent_level=1)
        self.header_writer.write_function_prototype(to_bundle_request, indent_level=1)
        self.header_writer.write_function_prototype(to_bundle_response, indent_level=1)
        self.header_writer.write("};", indent_level=0)

        # Convert to ROS

        # Requests
        self.source_writer.write(f"void ServiceTypeAdapter<{config.ros_type}>::convert_to_ros(const proton::BundleHandle & source, RequestROS & destination) {{", indent_level=0)

        if len(config.request_mappings) == 0:
            self.source_writer.write("RCL_UNUSED(source);")
            self.source_writer.write("RCL_UNUSED(destination);")
        else:
            for map in config.request_mappings:
                self.generate_mapping_to_ros(map)

        self.source_writer.write_function_end()

        # Responses
        self.source_writer.write(f"void ServiceTypeAdapter<{config.ros_type}>::convert_to_ros(const proton::BundleHandle & source, ResponseROS & destination) {{", indent_level=0)

        if len(config.response_mappings) == 0:
            self.source_writer.write("RCL_UNUSED(source);")
            self.source_writer.write("RCL_UNUSED(destination);")
        else:
            for map in config.response_mappings:
                self.generate_mapping_to_ros(map)

        self.source_writer.write_function_end()

        # Convert to Bundle

        # Requests
        self.source_writer.write(f"void ServiceTypeAdapter<{config.ros_type}>::convert_to_bundle(const RequestROS & source, proton::BundleHandle & destination) {{", indent_level=0)

        if len(config.request_mappings) == 0:
            self.source_writer.write("RCL_UNUSED(source);")
            self.source_writer.write("RCL_UNUSED(destination);")
        else:
            for map in config.request_mappings:
                self.generate_mapping_to_bundle(map)

        self.source_writer.write_function_end()

        # Responses
        self.source_writer.write(f"void ServiceTypeAdapter<{config.ros_type}>::convert_to_bundle(const ResponseROS & source, proton::BundleHandle & destination) {{", indent_level=0)

        if len(config.response_mappings) == 0:
            self.source_writer.write("RCL_UNUSED(source);")
            self.source_writer.write("RCL_UNUSED(destination);")
        else:
            for map in config.response_mappings:
                self.generate_mapping_to_bundle(map)

        self.source_writer.write_function_end()

    def generate(self):
        self.header_writer = CPPWriter(
            self.header_path,
            self.generated_header_name,
            f"{self.generated_header_name.upper().replace('.', '_')}_{"MSG" if self.is_message else "SRV"}"
        )

        self.source_writer = CPPWriter(
            self.source_path,
            self.generated_source_name,
        )

        self.header_writer.write_header_guard_open()
        self.header_writer.write_include("proton_ros2/typed.hpp")
        if self.is_message:
            self.header_writer.write_include("proton_ros2/utils.hpp")
        self.header_writer.write_newline()

        if self.is_message:
            for m in self.config.messages:
                if m.skip:
                    continue
                self.header_writer.write_include(m.hpp_header)
        else:
            for s in self.config.services:
                if s.skip:
                    continue
                self.header_writer.write_include(s.hpp_header)
            self.header_writer.write_newline()
            self.header_writer.write("namespace proton::ros2 {", indent_level=0)
        self.header_writer.write_newline()

        self.source_writer.write_include(self.generated_include)
        self.source_writer.write_newline()

        if not self.is_message:
            self.source_writer.write("using namespace proton::ros2;", indent_level=0)
            self.source_writer.write_newline()

        if self.is_message:
            for m in self.config.messages:
                if m.skip:
                    continue
                self.generate_message_type_adapter(m)
                self.header_writer.write_newline()
        else:
            for s in self.config.services:
                if s.skip:
                    continue
                self.generate_service_type_adapter(s)
                self.header_writer.write_newline()

        if not self.is_message:
            self.header_writer.write("}  // namespace proton::ros2", indent_level=0)
            self.header_writer.write_newline()

        self.header_writer.write_header_guard_close()
        self.header_writer.close_file()
        self.source_writer.close_file()


class ProtonROS2FactoryGenerator:
    def __init__(
        self, conversions: List[ProtonROS2AdapterGenerator], header_path: str, source_path: str
    ):
        self.conversions = conversions
        self.header_path = header_path
        self.source_path = source_path
        if not os.path.exists(self.header_path):
            os.mkdir(self.header_path)
        if not os.path.exists(self.source_path):
            os.mkdir(self.source_path)
        self.header_file = 'factory.hpp'
        self.source_file = 'factory.cpp'
        self.generated_include = f"{ProtonROS2AdapterGenerator.PROTON_ROS2}/{self.header_file}"

    def generate_publisher_factory(self):
        parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("topic", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
        ]
        f = Function("createTypedPublisher", parameters, "static std::shared_ptr<IPublisher>")
        self.header_writer.write_function_prototype(f, indent_level=1)
        self.source_writer.write("std::shared_ptr<IPublisher> Factory::createTypedPublisher(const std::string& type, rclcpp::Node * node, const std::string& topic, const rclcpp::QoS & qos) {", indent_level=0)
        first = True
        for c in self.conversions:
            # Skip services
            if not c.is_message:
                continue
            for m in c.config.messages:
                if m.skip:
                    continue
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedPublisher<{m.ros_type}>>(node, topic, qos);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid publisher message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

    def generate_subscriber_factory(self):
        parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("topic", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
            Variable("bundle", "proton::BundleHandle &"),
            Variable("callback", "proton::BundleHandle::BundleCallback"),
        ]
        f = Function("createTypedSubscriber", parameters, "static std::shared_ptr<ISubscriber>")
        self.header_writer.write_function_prototype(f, indent_level=1)

        self.source_writer.write("std::shared_ptr<ISubscriber> Factory::createTypedSubscriber(const std::string& type, rclcpp::Node * node, const std::string& topic, const rclcpp::QoS & qos, proton::BundleHandle & bundle, proton::BundleHandle::BundleCallback callback) {", indent_level=0)
        first = True
        for c in self.conversions:
            # Skip services
            if not c.is_message:
                continue
            for m in c.config.messages:
                if m.skip:
                    continue
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedSubscriber<{m.ros_type}>>(node, topic, qos, bundle, callback);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid subscriber message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

    def generate_services_factory(self):
        request_parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("service_name", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
            Variable("timeout_ms", "const uint32_t"),
            Variable("request_bundle", "proton::BundleHandle &"),
            Variable("callback", "proton::BundleHandle::BundleCallback"),
        ]

        request_response_parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("service_name", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
            Variable("timeout_ms", "const uint32_t"),
            Variable("request_bundle", "proton::BundleHandle &"),
            Variable("response_bundle", "proton::BundleHandle &"),
            Variable("callback", "proton::BundleHandle::BundleCallback"),
        ]

        request_function = Function("createTypedService", request_parameters, "static std::shared_ptr<IService>")
        request_response_function = Function("createTypedService", request_response_parameters, "static std::shared_ptr<IService>")
        self.header_writer.write_function_prototype(request_function, indent_level=1)
        self.header_writer.write_function_prototype(request_response_function, indent_level=1)

        # Request function definition
        self.source_writer.write("std::shared_ptr<IService> Factory::createTypedService(const std::string& type, rclcpp::Node * node, const std::string& service_name, const rclcpp::QoS & qos, const uint32_t timeout_ms, proton::BundleHandle & request_bundle, proton::BundleHandle::BundleCallback callback) {", indent_level=0)
        first = True
        for c in self.conversions:
            # Skip messages
            if c.is_message:
                continue
            for s in c.config.services:
                if s.skip:
                    continue
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedService<{s.ros_type}>>(node, service_name, qos, timeout_ms, request_bundle, callback);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid service message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

        # Request response function definition
        self.source_writer.write("std::shared_ptr<IService> Factory::createTypedService(const std::string& type, rclcpp::Node * node, const std::string& service_name, const rclcpp::QoS & qos, const uint32_t timeout_ms, proton::BundleHandle & request_bundle, proton::BundleHandle & response_bundle, proton::BundleHandle::BundleCallback callback) {", indent_level=0)
        first = True
        for c in self.conversions:
            # Skip messages
            if c.is_message:
                continue
            for s in c.config.services:
                if s.skip:
                    continue
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedService<{s.ros_type}>>(node, service_name, qos, timeout_ms, request_bundle, response_bundle, callback);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid service message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

    def generate_client_factory(self):
        request_parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("service_name", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
            Variable("timeout_ms", "const uint32_t"),
        ]

        request_response_parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("service_name", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
            Variable("timeout_ms", "const uint32_t"),
            Variable("response_bundle", "proton::BundleHandle &"),
            Variable("callback", "proton::BundleHandle::BundleCallback"),
        ]

        request_function = Function("createTypedClient", request_parameters, "static std::shared_ptr<IClient>")
        request_response_function = Function("createTypedClient", request_response_parameters, "static std::shared_ptr<IClient>")
        self.header_writer.write_function_prototype(request_function, indent_level=1)
        self.header_writer.write_function_prototype(request_response_function, indent_level=1)

        # Request function definition
        self.source_writer.write("std::shared_ptr<IClient> Factory::createTypedClient(const std::string& type, rclcpp::Node * node, const std::string& service_name, const rclcpp::QoS & qos, const uint32_t timeout_ms) {", indent_level=0)
        first = True
        for c in self.conversions:
            # Skip messages
            if c.is_message:
                continue
            for s in c.config.services:
                if s.skip:
                    continue
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedClient<{s.ros_type}>>(node, service_name, qos, timeout_ms);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid client message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

        # Request response function definition
        self.source_writer.write("std::shared_ptr<IClient> Factory::createTypedClient(const std::string& type, rclcpp::Node * node, const std::string& service_name, const rclcpp::QoS & qos, const uint32_t timeout_ms, proton::BundleHandle & response_bundle, proton::BundleHandle::BundleCallback callback) {", indent_level=0)
        first = True
        for c in self.conversions:
            # Skip messages
            if c.is_message:
                continue
            for s in c.config.services:
                if s.skip:
                    continue
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{s.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedClient<{s.ros_type}>>(node, service_name, qos, timeout_ms, &response_bundle, callback);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid client message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

    def generate(self):
        self.header_writer = CPPWriter(
            self.header_path,
            self.header_file,
        )

        self.source_writer = CPPWriter(
            self.source_path,
            self.source_file,
        )

        self.header_writer.write_header_guard_open()
        self.header_writer.write_include("proton_ros2/typed.hpp")
        for c in self.conversions:
            self.header_writer.write_include(c.generated_include)
        self.header_writer.write_newline()
        self.header_writer.write("namespace proton::ros2 {", indent_level=0)
        self.header_writer.write_newline()
        self.header_writer.write("class Factory {", indent_level=0)
        self.header_writer.write("public:", indent_level=0)

        self.source_writer.write_include(self.generated_include)
        self.source_writer.write_newline()
        self.source_writer.write("using namespace proton::ros2;", indent_level=0)
        self.source_writer.write_newline()

        self.generate_publisher_factory()
        self.generate_subscriber_factory()
        self.generate_services_factory()
        self.generate_client_factory()

        self.header_writer.write("};", indent_level=0)
        self.header_writer.write_newline()
        self.header_writer.write("}  // namespace proton::ros2", indent_level=0)
        self.header_writer.write_newline()
        self.header_writer.write_header_guard_close()

        self.header_writer.close_file()
        self.source_writer.close_file()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--config_folder",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/config/",
        help="Configuration folder path.",
    )

    parser.add_argument(
        "--destination_header",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/test/include/proton_ros2/",
        help="Destination folder path for generated header files.",
    )

    parser.add_argument(
        "--destination_source",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/test/src",
        help="Destination folder path for generated source files.",
    )

    parser.add_argument(
        "--destination_config",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/test/config",
        help="Destination folder path for generated config files.",
    )

    parser.add_argument(
        "-m",
        "--msgs",
        type=str,
        action="append",
        help="Message packages",
    )

    parser.add_argument(
        "-s",
        "--srvs",
        type=str,
        action="append",
        help="Service packages",
    )

    args = parser.parse_args()

    folder = args.config_folder

    messages_folder = os.path.join(folder, "messages")
    services_folder = os.path.join(folder, "services")
    header = args.destination_header
    source = args.destination_source

    config_folder = args.destination_config
    config_messages_folder = os.path.join(config_folder, "messages")
    config_services_folder = os.path.join(config_folder, "services")

    message_packages = args.msgs
    message_packages = [m.strip() for m in message_packages]
    service_packages = args.srvs
    service_packages = [s.strip() for s in service_packages]

    message_package_configs = {}
    service_package_configs = {}

    for m in message_packages:
        message_package_configs[m] = get_package_config(m)

    for s in service_packages:
        service_package_configs[s] = get_package_config(s)

    message_files = os.listdir(messages_folder)
    service_files = os.listdir(services_folder)
    generators: List[ProtonROS2AdapterGenerator] = []

    # Update message configs from config file
    for f in message_files:
        name, ext = os.path.splitext(f)
        if ext == ".yaml":
            if name in message_packages:
                overwrite_config = yaml.load(open(os.path.join(messages_folder, f)), Loader=yaml.SafeLoader)
                package_config = message_package_configs[name]
                for overwrite_message in overwrite_config[ProtonROS2Config.MESSAGES]:
                    for i, package_message in enumerate(package_config[ProtonROS2Config.MESSAGES]):
                        if overwrite_message[ProtonROS2Config.Message.NAME] == package_message[ProtonROS2Config.Message.NAME]:
                            message_package_configs[name][ProtonROS2Config.MESSAGES][i] = overwrite_message

    for p, config in message_package_configs.items():
        if len(config[ProtonROS2Config.MESSAGES]) > 0:
            generator = ProtonROS2AdapterGenerator(message_package_configs[p], header, source, is_message=True)
            generator.generate()
            generators.append(generator)
            with open(os.path.join(config_messages_folder, f'{p}.yaml'), 'w') as f:
                yaml.dump(config[ProtonROS2Config.MESSAGES], f)

    for f in service_files:
        name, ext = os.path.splitext(f)
        if ext == ".yaml":
            if name in service_packages:
                overwrite_config = yaml.load(open(os.path.join(services_folder, f)), Loader=yaml.SafeLoader)
                package_config = service_package_configs[name]
                for overwrite_service in overwrite_config[ProtonROS2Config.SERVICES]:
                    for i, package_service in enumerate(package_config[ProtonROS2Config.SERVICES]):
                        if overwrite_service[ProtonROS2Config.Service.NAME] == package_service[ProtonROS2Config.Service.NAME]:
                            service_package_configs[name][ProtonROS2Config.SERVICES][i] = overwrite_service

    for p, config in service_package_configs.items():
        if len(config[ProtonROS2Config.SERVICES]) > 0:
            generator = ProtonROS2AdapterGenerator(service_package_configs[p], header, source, is_message=False)
            generator.generate()
            generators.append(generator)
            with open(os.path.join(config_services_folder, f'{p}.yaml'), 'w') as f:
                yaml.dump(config[ProtonROS2Config.SERVICES], f)

    factory_generator = ProtonROS2FactoryGenerator(generators, header, source)
    factory_generator.generate()


if __name__ == "__main__":
    main()
