#!/usr/bin/env python3

# Software License Agreement (BSD)
#
# @author    Roni Kreinin <rkreinin@clearpathrobotics.com>
# @copyright (c) 2025, Clearpath Robotics, Inc., All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of Clearpath Robotics nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import argparse
import os
import yaml

from typing import List

from proton_ros2.message_config import ProtonROS2MessageConfig
from proton_ros2.source_writer import CPPWriter, Function, Variable


class ProtonROS2AdapterGenerator:
    SignalMap = {
        "double": "double",
        "float": "float",
        "int32": "int32_t",
        "int64": "int64_t",
        "uint32": "uint32_t",
        "uint64": "uint64_t",
        "bool": "bool",
        "string": "std::string",
        "bytes": "proton::bytes",
    }

    ListSignalMap = {
        "double": "proton::list_double",
        "float": "proton::list_float",
        "int32": "proton::list_int32",
        "int64": "proton::list_int64",
        "uint32": "proton::list_uint32",
        "uint64": "proton::list_uint64",
        "bool": "proton::list_bool",
        "string": "proton::list_string",
        "bytes": "proton::bytes",
    }

    PROTON_ROS2 = "proton_ros2"
    ADAPTERS = "adapters"

    def __init__(self, config_file: str, destination_header: str, destination_source: str):
        self.config_file = config_file
        self.header_path = destination_header
        self.source_path = destination_source
        assert os.path.exists(self.config_file)
        if not os.path.exists(self.header_path):
            os.mkdir(self.header_path)
        if not os.path.exists(self.source_path):
            os.mkdir(self.source_path)

        self.dictionary = self.read_yaml()
        self.config = ProtonROS2MessageConfig(self.dictionary)
        self.generated_header_name = f"{self.config.package}.hpp"
        self.generated_source_name = f"{self.config.package}.cpp"
        self.generated_include = f"{self.PROTON_ROS2}/{self.ADAPTERS}/{self.generated_header_name}"

    def read_yaml(self):
        # Check YAML can be Opened
        try:
            config = yaml.load(open(self.config_file), Loader=yaml.SafeLoader)
        except yaml.scanner.ScannerError:
            raise AssertionError(f'YAML file "{self.config_file}" is not well formed')
        except yaml.constructor.ConstructorError:
            raise AssertionError(
                f'YAML file "{self.config_file}" is attempting to create unsafe objects'
            )
        # Check contents are a Dictionary
        assert isinstance(config, dict), (
            f'YAML file "{self.config_file}" is not a dictionary'
        )
        return config

    def generate_type_adapter(self, config: ProtonROS2MessageConfig.Message):
        self.header_writer.write("template<>", indent_level=0)
        self.header_writer.write(
            f"struct rclcpp::TypeAdapter<proton::BundleHandle, {config.ros_type}> {{",
            indent_level=0,
        )
        self.header_writer.write(
            "using is_specialized = std::true_type;", indent_level=1
        )
        self.header_writer.write(
            "using custom_type = proton::BundleHandle;", indent_level=1
        )
        self.header_writer.write(
            f"using ros_message_type = {config.ros_type};", indent_level=1
        )
        self.header_writer.write_newline()

        to_ros = Function("convert_to_ros_message",
                          [Variable("source", "const custom_type &"),
                           Variable("destination", "ros_message_type &")],
                          "static void")

        to_custom = Function("convert_to_custom",
                          [Variable("source", "const ros_message_type &"),
                           Variable("destination", "custom_type &")],
                          "static void")

        self.header_writer.write_function_prototype(to_ros, indent_level=1)
        self.header_writer.write_function_prototype(to_custom, indent_level=1)
        self.header_writer.write("};", indent_level=0)

        # Convert to ROS
        self.source_writer.write(f"void rclcpp::TypeAdapter<proton::BundleHandle, {config.ros_type}>::convert_to_ros_message(const custom_type & source, ros_message_type & destination) {{", indent_level=0)
        if config.stamp:
            self.source_writer.write(
                f"destination.{config.stamp} = proton::ros2::Utils::getTimeStamp();",
                indent_level=1,
            )
        for map in config.mappings:
            self.source_writer.write(
                f'if (source.hasSignal("{map.proton_signal}")) {{', indent_level=1
            )

            match(map.mapping_type):
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.SCALAR:
                    self.source_writer.write(
                      f'destination.{map.ros_path} = source.getConstSignal("{map.proton_signal}").getValue<{self.SignalMap[map.data_type]}>();',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.PROTON_INDEXED:
                    self.source_writer.write(
                      f'destination.{map.ros_path} = source.getConstSignal("{map.proton_signal}").getValue<{self.ListSignalMap[map.data_type]}>().at({map.proton_index});',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.ROS_INDEXED:
                    self.source_writer.write(
                      f'destination.{map.ros_path}.at({map.proton_index}) = source.getConstSignal("{map.proton_signal}").getValue<{self.SignalMap[map.data_type]}>();',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.BOTH_INDEXED:
                    self.source_writer.write(
                      f'destination.{map.ros_path}.at({map.proton_index}) = source.getConstSignal("{map.proton_signal}").getValue<{self.SignalMap[map.data_type]}>().at({map.proton_index});',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.FIXED_LIST:
                    # Get signal list length
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'std::size_t len = source.getConstSignal("{map.proton_signal}").getCapacity();',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'std::size_t len = source.getConstSignal("{map.proton_signal}").getLength();',
                          indent_level=2,
                        )
                    # Limit array size to the minimum of the ROS array length, and the signal length
                    self.source_writer.write(
                      f"int n = std::min(len, destination.{map.ros_path}.size());",
                      indent_level=2,
                    )
                    # Copy proton list to ROS array
                    self.source_writer.write(f"auto {map.proton_signal} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.ListSignalMap[map.data_type]}>();", indent_level=2)
                    self.source_writer.write(
                      f"std::copy({map.proton_signal}.begin(), {map.proton_signal}.begin() + n, destination.{map.ros_path}.begin());",
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.DYNAMIC_LIST:
                    # Copy proton list to ROS vector
                    self.source_writer.write(f"destination.{map.ros_path} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.ListSignalMap[map.data_type]}>();", indent_level=2)
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.FIXED_SUBMESSAGE:
                    # Get signal list length
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'std::size_t len = source.getConstSignal("{map.proton_signal}").getCapacity();',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'std::size_t len = source.getConstSignal("{map.proton_signal}").getLength();',
                          indent_level=2,
                        )
                    # Limit array size to the minimum of the ROS array length, and the signal length
                    self.source_writer.write(
                      f"int n = std::min(len, destination.{map.ros_path}.size());",
                      indent_level=2,
                    )
                    # Copy proton list to ROS array
                    self.source_writer.write(f"{self.ListSignalMap[map.data_type]} {map.proton_signal} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.ListSignalMap[map.data_type]}>();", indent_level=2)
                    self.source_writer.write_for_loop_start("n",indent_level=2)
                    self.source_writer.write(f"destination.{map.ros_path}.at(i).{map.ros_subpath} = {map.proton_signal}.at(i);", indent_level=3)
                    self.source_writer.write_for_loop_end(indent_level=2)
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.DYNAMIC_SUBMESSAGE:
                    # Get signal list length
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'std::size_t len = source.getConstSignal("{map.proton_signal}").getCapacity();',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'std::size_t len = source.getConstSignal("{map.proton_signal}").getLength();',
                          indent_level=2,
                        )
                    # Limit array size to the minimum of the ROS array length, and the signal length
                    self.source_writer.write(
                      f"int n = std::min(len, destination.{map.ros_path}.size());",
                      indent_level=2,
                    )
                    # Resize ROS array to n
                    self.source_writer.write(
                      f"destination.{map.ros_path}.resize(n);",
                      indent_level=2,
                    )
                    # Copy proton list to ROS array
                    self.source_writer.write(f"{self.SignalMap[map.data_type]} {map.proton_signal} = source.getConstSignal(\"{map.proton_signal}\").getValue<{self.SignalMap[map.data_type]}>();", indent_level=2)
                    self.source_writer.write_for_loop_start("n",indent_level=2)
                    self.source_writer.write(f"destination.{map.ros_path}.at(i).{map.ros_subpath} = {map.proton_signal}.at(i);", indent_level=3)
                    self.source_writer.write_for_loop_end(indent_level=2)
            self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end()

        # Convert to Custom
        self.source_writer.write(f"void rclcpp::TypeAdapter<proton::BundleHandle, {config.ros_type}>::convert_to_custom(const ros_message_type & source, custom_type & destination) {{", indent_level=0)
        for map in config.mappings:
            self.source_writer.write(
                f'if (destination.hasSignal("{map.proton_signal}")) {{', indent_level=1
            )

            match(map.mapping_type):
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.SCALAR:
                    self.source_writer.write(
                      f'destination.getSignal("{map.proton_signal}").setValue<{self.SignalMap[map.data_type]}>(source.{map.ros_path});',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.PROTON_INDEXED:
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'destination.getSignal("{map.proton_signal}").setValue<uint8_t>({map.proton_index}, source.{map.ros_path});',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'destination.getSignal("{map.proton_signal}").setValue<{self.SignalMap[map.data_type]}>({map.proton_index}, source.{map.ros_path});',
                          indent_level=2,
                        )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.ROS_INDEXED:
                    self.source_writer.write(
                      f'destination.getSignal("{map.proton_signal}").setValue<{self.SignalMap[map.data_type]}>(source.{map.ros_path}.at({map.ros_index}));',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.BOTH_INDEXED:
                    self.source_writer.write(
                      f'destination.getSignal("{map.proton_signal}").setValue<{self.SignalMap[map.data_type]}>({map.proton_index}, source.{map.ros_path}.at({map.ros_index}));',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.FIXED_LIST:
                    # Get signal list length
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getCapacity();',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getLength();',
                          indent_level=2,
                        )
                    # Limit array size to the minimum of the ROS array length, and the signal length
                    self.source_writer.write(
                      f"int n = std::min(len, source.{map.ros_path}.size());",
                      indent_level=2,
                    )
                    # Create proton list type of n length
                    self.source_writer.write(
                      f"{self.ListSignalMap[map.data_type]} {map.proton_signal}(n);",
                      indent_level=2,
                    )
                    # Copy ROS array into proton list
                    self.source_writer.write(
                      f"std::copy(source.{map.ros_path}.begin(), source.{map.ros_path}.begin() + n, {map.proton_signal}.begin());",
                      indent_level=2,
                    )
                    # Set value
                    self.source_writer.write(
                      f'destination.getSignal("{map.proton_signal}").setValue<{self.ListSignalMap[map.data_type]}>({map.proton_signal});',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.DYNAMIC_LIST:
                    # Get signal list length
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getCapacity();',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getLength();',
                          indent_level=2,
                        )
                    # Limit array size to the minimum of the ROS array length, and the signal length
                    self.source_writer.write(
                      f"int n = std::min(len, source.{map.ros_path}.size());",
                      indent_level=2,
                    )
                    # Create proton list type of n length
                    self.source_writer.write(
                      f"{self.ListSignalMap[map.data_type]} {map.proton_signal}(n);",
                      indent_level=2,
                    )
                    # Copy ROS array into proton list
                    self.source_writer.write(
                      f"std::copy(source.{map.ros_path}.begin(), source.{map.ros_path}.begin() + n, {map.proton_signal}.begin());",
                      indent_level=2,
                    )
                    # Set value
                    self.source_writer.write(
                      f'destination.getSignal("{map.proton_signal}").setValue<{self.ListSignalMap[map.data_type]}>({map.proton_signal});',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.FIXED_SUBMESSAGE:
                    # Get signal list length
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getCapacity();',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getLength();',
                          indent_level=2,
                        )
                    # Limit array size to the minimum of the ROS array length, and the signal length
                    self.source_writer.write(
                      f"int n = std::min(len, source.{map.ros_path}.size());",
                      indent_level=2,
                    )
                    # Create proton list type of n length
                    self.source_writer.write(
                      f"{self.ListSignalMap[map.data_type]} {map.proton_signal}(n);",
                      indent_level=2,
                    )
                    self.source_writer.write_for_loop_start("n",indent_level=2)
                    self.source_writer.write(f"destination.getSignal(\"{map.proton_signal}\").setValue<{self.SignalMap[map.data_type]}>(i, source.{map.ros_path}.at(i).{map.ros_subpath});", indent_level=3)
                    self.source_writer.write_for_loop_end(indent_level=2)
                    # Set value
                    self.source_writer.write(
                      f'destination.getSignal("{map.proton_signal}").setValue<{self.ListSignalMap[map.data_type]}>({map.proton_signal});',
                      indent_level=2,
                    )
                case ProtonROS2MessageConfig.Message.Mapping.MappingType.DYNAMIC_SUBMESSAGE:
                    # Get signal list length
                    if map.data_type == "bytes":
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getCapacity();',
                          indent_level=2,
                        )
                    else:
                        self.source_writer.write(
                          f'std::size_t len = destination.getSignal("{map.proton_signal}").getLength();',
                          indent_level=2,
                        )
                    # Limit array size to the minimum of the ROS array length, and the signal length
                    self.source_writer.write(
                      f"int n = std::min(len, source.{map.ros_path}.size());",
                      indent_level=2,
                    )
                    # Create proton list type of n length
                    self.source_writer.write(
                      f"{self.ListSignalMap[map.data_type]} {map.proton_signal}(n);",
                      indent_level=2,
                    )
                    self.source_writer.write_for_loop_start("n",indent_level=2)
                    if map.data_type == "bytes":
                        self.source_writer.write(f"destination.getSignal(\"{map.proton_signal}\").setValue<uint8_t>(i, source.{map.ros_path}.at(i).{map.ros_subpath});", indent_level=3)
                    else:
                        self.source_writer.write(f"destination.getSignal(\"{map.proton_signal}\").setValue<{self.SignalMap[map.data_type]}>(i, source.{map.ros_path}.at(i).{map.ros_subpath});", indent_level=3)
                    self.source_writer.write_for_loop_end(indent_level=2)
                    # Set value
                    self.source_writer.write(
                      f'destination.getSignal("{map.proton_signal}").setValue<{self.ListSignalMap[map.data_type]}>({map.proton_signal});',
                      indent_level=2,
                    )
            self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end()

    def generate(self):
        self.header_writer = CPPWriter(
            self.header_path,
            self.generated_header_name,
        )

        self.source_writer = CPPWriter(
            self.source_path,
            self.generated_source_name,
        )

        self.header_writer.write_header_guard_open()
        self.header_writer.write_include("rclcpp/type_adapter.hpp")
        self.header_writer.write_include("protoncpp/bundle.hpp")
        self.header_writer.write_include(f"{self.PROTON_ROS2}/utils.hpp")
        self.header_writer.write_newline()

        for m in self.config.messages:
            self.header_writer.write_include(m.hpp_header)
        self.header_writer.write_newline()

        self.source_writer.write_include(self.generated_include)
        self.source_writer.write_newline()

        for m in self.config.messages:
            self.generate_type_adapter(m)
            self.header_writer.write_newline()

        self.header_writer.write_header_guard_close()
        self.header_writer.close_file()
        self.source_writer.close_file()


class ProtonROS2FactoryGenerator:
    def __init__(
        self, conversions: List[ProtonROS2AdapterGenerator], header_path: str, source_path: str
    ):
        self.conversions = conversions
        self.header_path = header_path
        self.source_path = source_path
        if not os.path.exists(self.header_path):
            os.mkdir(self.header_path)
        if not os.path.exists(self.source_path):
            os.mkdir(self.source_path)
        self.header_file = 'factory.hpp'
        self.source_file = 'factory.cpp'
        self.generated_include = f"{ProtonROS2AdapterGenerator.PROTON_ROS2}/{ProtonROS2AdapterGenerator.ADAPTERS}/{self.header_file}"

    def generate_publisher_factory(self):
        parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("topic", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
        ]
        f = Function("createTypedPublisher", parameters, "static std::shared_ptr<IPublisher>")
        self.header_writer.write_function_prototype(f, indent_level=1)
        self.source_writer.write("std::shared_ptr<IPublisher> Factory::createTypedPublisher(const std::string& type, rclcpp::Node * node, const std::string& topic, const rclcpp::QoS & qos) {", indent_level=0)
        first = True
        for c in self.conversions:
            for m in c.config.messages:
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedPublisher<{m.ros_type}>>(node, topic, qos);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid publisher message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

    def generate_subscriber_factory(self):
        parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("topic", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
            Variable("bundle", "proton::BundleHandle &"),
            Variable("callback", "proton::BundleHandle::BundleCallback"),
        ]
        f = Function("createTypedSubscriber", parameters, "static std::shared_ptr<ISubscriber>")
        self.header_writer.write_function_prototype(f, indent_level=1)

        self.source_writer.write("std::shared_ptr<ISubscriber> Factory::createTypedSubscriber(const std::string& type, rclcpp::Node * node, const std::string& topic, const rclcpp::QoS & qos, proton::BundleHandle & bundle, proton::BundleHandle::BundleCallback callback) {", indent_level=0)
        first = True
        for c in self.conversions:
            for m in c.config.messages:
                if first:
                    self.source_writer.write_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.source_writer.write_else_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                self.source_writer.write(f"return std::make_shared<TypedSubscriber<{m.ros_type}>>(node, topic, qos, bundle, callback);", indent_level=2)
                self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_else_statement_start(indent_level=1)
        self.source_writer.write("throw std::runtime_error(\"Invalid subscriber message type \" + type);", indent_level=2)
        self.source_writer.write_if_statement_end(indent_level=1)
        self.source_writer.write_function_end(indent_level=0)

    def generate(self):
        self.header_writer = CPPWriter(
            self.header_path,
            self.header_file,
        )

        self.source_writer = CPPWriter(
            self.source_path,
            self.source_file,
        )

        self.header_writer.write_header_guard_open()
        self.header_writer.write_include("proton_ros2/typed.hpp")
        for c in self.conversions:
            self.header_writer.write_include(c.generated_include)
        self.header_writer.write_newline()
        self.header_writer.write("namespace proton::ros2 {", indent_level=0)
        self.header_writer.write_newline()
        self.header_writer.write("class Factory {", indent_level=0)
        self.header_writer.write("public:", indent_level=0)

        self.source_writer.write_include(self.generated_include)
        self.source_writer.write("using namespace proton::ros2;", indent_level=0)
        self.source_writer.write_newline()

        self.generate_publisher_factory()
        self.generate_subscriber_factory()

        self.header_writer.write("};", indent_level=0)
        self.header_writer.write_newline()
        self.header_writer.write("}  // namespace proton::ros2", indent_level=0)
        self.header_writer.write_newline()
        self.header_writer.write_header_guard_close()

        self.header_writer.close_file()
        self.source_writer.close_file()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-c",
        "--config_folder",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/config/",
        help="Configuration folder path.",
    )

    parser.add_argument(
        "-d",
        "--destination_header",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/include/proton_ros2/adapters",
        help="Destination folder path for generated header files.",
    )

    parser.add_argument(
        "-s",
        "--destination_source",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/src/adapters",
        help="Destination folder path for generated source files.",
    )

    args = parser.parse_args()

    folder = args.config_folder
    header = args.destination_header
    source = args.destination_source

    files = os.listdir(folder)
    generators: List[ProtonROS2AdapterGenerator] = []
    for f in files:
        _, ext = os.path.splitext(f)
        if ext == ".yaml":
            generator = ProtonROS2AdapterGenerator(os.path.join(folder, f), header, source)
            generator.generate()
            generators.append(generator)

    factory_generator = ProtonROS2FactoryGenerator(generators, header, source)
    factory_generator.generate()


if __name__ == "__main__":
    main()
