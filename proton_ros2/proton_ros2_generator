#!/usr/bin/env python3

# Software License Agreement (BSD)
#
# @author    Roni Kreinin <rkreinin@clearpathrobotics.com>
# @copyright (c) 2025, Clearpath Robotics, Inc., All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of Clearpath Robotics nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import argparse
import os
import yaml

from typing import List

from proton_ros2.config import ProtonROS2MessageConfig
from proton_ros2.source_writer import CPPWriter, Function, Variable


class ProtonROS2AdapterGenerator:
    SignalMap = {
        "double": "double",
        "float": "float",
        "int32": "int32_t",
        "int64": "int64_t",
        "uint32": "uint32_t",
        "uint64": "uint64_t",
        "bool": "bool",
        "string": "std::string",
        "bytes": "uint8_t",
    }

    ListSignalMap = {
        "double": "proton::list_double",
        "float": "proton::list_float",
        "int32": "proton::list_int32",
        "int64": "proton::list_int64",
        "uint32": "proton::list_uint32",
        "uint64": "proton::list_uint64",
        "bool": "proton::list_bool",
        "string": "proton::list_string",
        "bytes": "proton::bytes",
    }

    PROTON_ROS2 = "proton_ros2"
    ADAPTERS = "adapters"

    def __init__(self, config_file: str, destination_path: str):
        self.config_file = config_file
        self.destination_path = destination_path
        assert os.path.exists(self.config_file)
        if not os.path.exists(self.destination_path):
            os.mkdir(self.destination_path)

        self.dictionary = self.read_yaml()
        self.config = ProtonROS2MessageConfig(self.dictionary)
        self.generated_file_name = f"{self.config.package}.hpp"
        self.generated_include = f"{self.PROTON_ROS2}/{self.ADAPTERS}/{self.generated_file_name}"

    def read_yaml(self):
        # Check YAML can be Opened
        try:
            config = yaml.load(open(self.config_file), Loader=yaml.SafeLoader)
        except yaml.scanner.ScannerError:
            raise AssertionError(f'YAML file "{self.config_file}" is not well formed')
        except yaml.constructor.ConstructorError:
            raise AssertionError(
                f'YAML file "{self.config_file}" is attempting to create unsafe objects'
            )
        # Check contents are a Dictionary
        assert isinstance(config, dict), (
            f'YAML file "{self.config_file}" is not a dictionary'
        )
        return config

    def generate_type_adapter(self, config: ProtonROS2MessageConfig):
        self.header_writer.write("template<>", indent_level=0)
        self.header_writer.write(
            f"struct rclcpp::TypeAdapter<proton::BundleHandle, {config.ros_type}> {{",
            indent_level=0,
        )
        self.header_writer.write(
            "using is_specialized = std::true_type;", indent_level=1
        )
        self.header_writer.write(
            "using custom_type = proton::BundleHandle;", indent_level=1
        )
        self.header_writer.write(
            f"using ros_message_type = {config.ros_type};", indent_level=1
        )
        self.header_writer.write_newline()

        # Convert to ROS
        self.header_writer.write(
            "static void convert_to_ros_message(const custom_type & source,ros_message_type & destination) {",
            indent_level=1,
        )
        if config.stamp:
            self.header_writer.write(
                f"destination.{config.stamp} = proton::ros2::getTimeStamp();",
                indent_level=2,
            )
        for map in config.mappings:
            self.header_writer.write(
                f'if (source.hasSignal("{map.signal}")) {{', indent_level=2
            )
            path = map.ros_path
            if map.ros_index is not None:
                path += f".at({map.ros_index})"
            if map.ros_subpath is not None:
                path += f".{map.ros_subpath}"

            if map.index is not None:
                self.header_writer.write(
                    f'destination.{path} = source.getConstSignal("{map.signal}").getValue<{self.ListSignalMap[map.type]}>().at({map.index});',
                    indent_level=3,
                )
            elif map.length == 0:
                self.header_writer.write(
                    f'destination.{path} = source.getConstSignal("{map.signal}").getValue<{self.ListSignalMap[map.type]}>();',
                    indent_level=3,
                )
            elif map.length is not None:
                self.header_writer.write(
                    f'{self.ListSignalMap[map.type]} {map.signal} = source.getConstSignal("{map.signal}").getValue<{self.ListSignalMap[map.type]}>();',
                    indent_level=3,
                )
                self.header_writer.write(
                    f"std::copy({map.signal}.begin(), {map.signal}.end(), destination.{path}.begin());",
                    indent_level=3,
                )
            elif map.ros_length == 0:
                if map.type == "bytes":
                    self.header_writer.write(
                        f'std::size_t len = source.getConstSignal(\"{map.signal}\").getCapacity();',
                        indent_level=3,
                    )
                else:
                    self.header_writer.write(
                        f'std::size_t len = source.getConstSignal(\"{map.signal}\").getLength();',
                        indent_level=3,
                    )
                self.header_writer.write(
                    f"int n = std::min(len, destination.{map.ros_path}.size());",
                    indent_level=3,
                )
                self.header_writer.write_for_loop_start("n",indent_level=3)
                if map.ros_subpath:
                    self.header_writer.write(f"destination.{map.ros_path}.at(i).{map.ros_subpath} = source.getConstSignal(\"{map.signal}\").getValue<{self.ListSignalMap[map.type]}>().at(i);", indent_level=4)
                else:
                    self.header_writer.write(f"destination.{map.ros_path}.at(i) = source.getConstSignal(\"{map.signal}\").getValue<{self.ListSignalMap[map.type]}>().at(i);", indent_level=4)
                self.header_writer.write_for_loop_end(indent_level=3)
            elif map.ros_length is not None:
                self.header_writer.write_for_loop_start(f"{map.ros_length}", indent_level=3)
                if map.ros_subpath:
                    self.header_writer.write(f"destination.{map.ros_path}.at(i).{map.ros_subpath} = source.getConstSignal(\"{map.signal}\").getValue<{self.ListSignalMap[map.type]}>().at(i);", indent_level=4)
                else:
                    self.header_writer.write(f"destination.{map.ros_path}.at(i) = source.getConstSignal(\"{map.signal}\").getValue<{self.ListSignalMap[map.type]}>().at(i);", indent_level=4)
                self.header_writer.write_for_loop_end(indent_level=3)
            else:
                self.header_writer.write(
                    f'destination.{path} = source.getConstSignal("{map.signal}").getValue<{self.SignalMap[map.type]}>();',
                    indent_level=3,
                )
            self.header_writer.write("}", indent_level=2)
        self.header_writer.write("}", indent_level=1)
        self.header_writer.write_newline()

        # Convert to Custom
        self.header_writer.write(
            "static void convert_to_custom(const ros_message_type & source, custom_type & destination) {",
            indent_level=1,
        )
        for map in config.mappings:
            self.header_writer.write(
                f'if (destination.hasSignal("{map.signal}")) {{', indent_level=2
            )
            path = map.ros_path
            if map.ros_index is not None:
                path += f".at({map.ros_index})"
            if map.ros_subpath is not None:
                path += f".{map.ros_subpath}"

            if map.index is not None:
                self.header_writer.write(
                    f'destination.getSignal("{map.signal}").setValue<{self.SignalMap[map.type]}>({map.index}, source.{path});',
                    indent_level=3,
                )
            elif map.length == 0:
                self.header_writer.write(
                    f'std::size_t len = destination.getSignal("{map.signal}").getLength();',
                    indent_level=3,
                )
                self.header_writer.write(
                    f"{self.ListSignalMap[map.type]} {map.signal}(len);", indent_level=3
                )
                self.header_writer.write(
                    f"int n = std::min(len, source.{path}.size());",
                    indent_level=3,
                )
                self.header_writer.write(
                    f"std::copy(source.{path}.begin(), source.{path}.begin() + n, {map.signal}.begin());",
                    indent_level=3,
                )
                self.header_writer.write(
                    f'destination.getSignal("{map.signal}").setValue<{self.ListSignalMap[map.type]}>({map.signal});',
                    indent_level=3,
                )
            elif map.length is not None:
                self.header_writer.write(
                    f"{self.ListSignalMap[map.type]} {map.signal}({map.length});",
                    indent_level=3,
                )
                self.header_writer.write(
                    f"std::copy(source.{path}.begin(), source.{path}.end(), {map.signal}.begin());",
                    indent_level=3,
                )
                self.header_writer.write(
                    f'destination.getSignal("{map.signal}").setValue<{self.ListSignalMap[map.type]}>({map.signal});',
                    indent_level=3,
                )
            elif map.ros_length == 0:
                if map.type == "bytes":
                    self.header_writer.write(
                        f'std::size_t len = destination.getConstSignal(\"{map.signal}\").getCapacity();',
                        indent_level=3,
                    )
                else:
                    self.header_writer.write(
                        f'std::size_t len = destination.getConstSignal(\"{map.signal}\").getLength();',
                        indent_level=3,
                    )
                self.header_writer.write(
                    f"int n = std::min(len, source.{map.ros_path}.size());",
                    indent_level=3,
                )
                self.header_writer.write_for_loop_start("n",indent_level=3)
                if map.ros_subpath:
                    self.header_writer.write(f"destination.getSignal(\"{map.signal}\").setValue<{self.SignalMap[map.type]}>(i, source.{map.ros_path}.at(i).{map.ros_subpath});", indent_level=4)
                else:
                    self.header_writer.write(f"destination.getSignal(\"{map.signal}\").setValue<{self.SignalMap[map.type]}>(i, source.{map.ros_path}.at(i);", indent_level=4)
                self.header_writer.write_for_loop_end(indent_level=3)
            elif map.ros_length is not None:
                self.header_writer.write_for_loop_start(f'{map.ros_length}',indent_level=3)
                if map.ros_subpath:
                    self.header_writer.write(f"destination.getSignal(\"{map.signal}\").setValue<{self.SignalMap[map.type]}>(i, source.{map.ros_path}.at(i).{map.ros_subpath});", indent_level=4)
                else:
                    self.header_writer.write(f"destination.getSignal(\"{map.signal}\").setValue<{self.SignalMap[map.type]}>(i, source.{map.ros_path}.at(i);", indent_level=4)
                self.header_writer.write_for_loop_end(indent_level=3)
            else:
                self.header_writer.write(
                    f'destination.getSignal("{map.signal}").setValue<{self.SignalMap[map.type]}>(source.{path});',
                    indent_level=3,
                )
            self.header_writer.write("}", indent_level=2)
        self.header_writer.write("}", indent_level=1)

        self.header_writer.write("};", indent_level=0)

    def generate(self):
        self.header_writer = CPPWriter(
            self.destination_path,
            self.generated_file_name,
        )

        self.header_writer.write_header_guard_open()
        self.header_writer.write_include("rclcpp/type_adapter.hpp")
        self.header_writer.write_include("protoncpp/bundle.hpp")
        self.header_writer.write_include(f"{self.PROTON_ROS2}/{self.ADAPTERS}/utils.hpp")
        self.header_writer.write_newline()

        for m in self.config.messages:
            self.header_writer.write_include(m.hpp_header)

        self.header_writer.write_newline()

        for m in self.config.messages:
            self.generate_type_adapter(m)
            self.header_writer.write_newline()

        self.header_writer.write_header_guard_close()

        self.header_writer.close_file()


class ProtonROS2FactoryGenerator:
    def __init__(
        self, conversions: List[ProtonROS2AdapterGenerator], destination_path: str
    ):
        self.conversions = conversions
        self.destination_path = destination_path
        if not os.path.exists(self.destination_path):
            os.mkdir(self.destination_path)

    def generate_publisher_factory(self):
        parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("topic", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
        ]
        f = Function("createTypedPublisher", parameters, "static std::shared_ptr<IPublisher>")
        self.header_writer.write_function_start(f, indent_level=0)
        first = True
        for c in self.conversions:
            for m in c.config.messages:
                if first:
                    self.header_writer.write_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.header_writer.write_else_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                self.header_writer.write(f"return std::make_shared<TypedPublisher<{m.ros_type}>>(node, topic, qos);", indent_level=2)
                self.header_writer.write_if_statement_end(indent_level=1)
        self.header_writer.write_else_statement_start(indent_level=1)
        self.header_writer.write("throw std::runtime_error(\"Invalid publisher message type \" + type);", indent_level=2)
        self.header_writer.write_if_statement_end(indent_level=1)
        self.header_writer.write_function_end(indent_level=0)

    def generate_subscriber_factory(self):
        parameters: List[Variable] = [
            Variable("type", "const std::string&"),
            Variable("node", "rclcpp::Node *"),
            Variable("topic", "const std::string&"),
            Variable("qos", "const rclcpp::QoS &"),
            Variable("bundle", "proton::BundleHandle &"),
            Variable("callback", "proton::BundleHandle::BundleCallback"),
        ]
        f = Function("createTypedSubscriber", parameters, "static std::shared_ptr<ISubscriber>")
        self.header_writer.write_function_start(f, indent_level=0)
        first = True
        for c in self.conversions:
            for m in c.config.messages:
                if first:
                    self.header_writer.write_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                    first = False
                else:
                    self.header_writer.write_else_if_statement_start(f"type == \"{m.full_name}\"", indent_level=1)
                self.header_writer.write(f"return std::make_shared<TypedSubscriber<{m.ros_type}>>(node, topic, qos, bundle, callback);", indent_level=2)
                self.header_writer.write_if_statement_end(indent_level=1)
        self.header_writer.write_else_statement_start(indent_level=1)
        self.header_writer.write("throw std::runtime_error(\"Invalid subscriber message type \" + type);", indent_level=2)
        self.header_writer.write_if_statement_end(indent_level=1)
        self.header_writer.write_function_end(indent_level=0)

    def generate(self):
        self.header_writer = CPPWriter(
            self.destination_path,
            "factory.hpp",
        )

        self.header_writer.write_header_guard_open()
        self.header_writer.write_include("proton_ros2/typed.hpp")
        for c in self.conversions:
            self.header_writer.write_include(c.generated_include)
        self.header_writer.write_newline()
        self.header_writer.write("namespace proton::ros2 {", indent_level=0)
        self.header_writer.write_newline()

        self.generate_publisher_factory()
        self.generate_subscriber_factory()

        self.header_writer.write("}  // namespace proton::ros2", indent_level=0)
        self.header_writer.write_newline()
        self.header_writer.write_header_guard_close()

        self.header_writer.close_file()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-c",
        "--config_folder",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/config/",
        help="Configuration folder path.",
    )

    parser.add_argument(
        "-d",
        "--destination",
        type=str,
        action="store",
        default="/home/rkreinin/proto_ws/src/proton_ros2/include/proton_ros2/adapters/",
        help="Destination folder path for generated files.",
    )

    args = parser.parse_args()

    folder = args.config_folder
    dest = args.destination

    files = os.listdir(folder)
    generators: List[ProtonROS2AdapterGenerator] = []
    for f in files:
        _, ext = os.path.splitext(f)
        if ext == ".yaml":
            generator = ProtonROS2AdapterGenerator(os.path.join(folder, f), dest)
            generator.generate()
            generators.append(generator)

    factory_generator = ProtonROS2FactoryGenerator(generators, dest)
    factory_generator.generate()


if __name__ == "__main__":
    main()
