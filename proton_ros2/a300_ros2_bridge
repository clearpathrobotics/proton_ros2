#!/usr/bin/env python3

import socket
import threading
import time
import random
import sys

from typing import List

import rclpy
from rclpy.node import Node

from proton_ros2.signal_pb2 import (
  Signal,
  ListFloats,
  ListDoubles,
  ListBools,
  ListInt32s,
  ListInt64s,
  ListStrings,
  ListUint32s,
  ListUint64s
)
from proton_ros2.bundle_pb2 import Bundle

from google.protobuf.message import DecodeError

from clearpath_platform_msgs.msg import Status, Power, Temperature, StopStatus, PinoutCommand, PinoutState, Lights, Fans, DisplayStatus, RGB
from sensor_msgs.msg import BatteryState
from rcl_interfaces.msg import Log
from std_msgs.msg import Header, Bool, String
from std_srvs.srv import Empty
from rclpy.qos import qos_profile_sensor_data, QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy

# PC_IP = '192.168.131.1'
# MCU_IP = '192.168.131.2'
# PROTON_PC_PORT = 11417
# PROTON_MCU_PORT = 11417

PC_IP = '127.0.0.1'
MCU_IP = '127.0.0.1'
PROTON_PC_PORT = 11417
PROTON_MCU_PORT = 11416

sock = socket.socket(socket.AF_INET, # Internet
                     socket.SOCK_DGRAM) # UDP
sock.bind((PC_IP, PROTON_PC_PORT))


class ProtonProcess(Node):
    LOGGER_ID=0x100
    STATUS_ID=0x101
    POWER_ID=0x102
    ESTOP_ID=0x103
    TEMP_ID=0x104
    STOP_ID=0x105
    PINOUT_STATE_ID=0x106
    ALERTS_ID=0x107

    CMD_FANS_ID=0x200
    DISPLAY_STATUS_ID=0x201
    CMD_LIGHTS_ID=0x202
    BATTERY_ID=0x203
    PINOUT_COMMAND_ID=0x204

    CMD_SHUTDOWN_TRIGGER=0x300
    CMD_SHUTDOWN_RESPONSE=0x300
    CLEAR_NEEDS_RESET=0x301

    def __init__(self):
        super().__init__('proton_a300_node')
        self.status_pub = self.create_publisher(Status, 'platform/mcu/status', qos_profile_sensor_data)
        self.power_pub = self.create_publisher(Power, 'platform/mcu/status/power', qos_profile_sensor_data)
        self.temperature_pub = self.create_publisher(Temperature, 'platform/mcu/status/temperature', qos_profile_sensor_data)
        self.estop_pub = self.create_publisher(Bool, 'platform/emergency_stop', qos_profile_sensor_data)
        self.stop_pub = self.create_publisher(StopStatus, 'platform/mcu/status/stop', qos_profile_sensor_data)
        self.pinout_state_pub = self.create_publisher(PinoutState, 'platform/mcu/status/pinout', qos_profile_sensor_data)
        self.alerts_pub = self.create_publisher(String, 'platform/mcu/status/alerts', qos_profile_sensor_data)
        self.rosout_pub = self.create_publisher(Log, '/rosout', QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=100,
            durability=DurabilityPolicy.TRANSIENT_LOCAL
        ))

        self.battery_sub = self.create_subscription(BatteryState, 'platform/bms/state', self.battery_cb, qos_profile_sensor_data)
        self.display_status_sub = self.create_subscription(DisplayStatus, 'platform/display/status', self.display_cb, qos_profile_sensor_data)
        self.cmd_fans_sub = self.create_subscription(Fans, 'platform/mcu/_cmd_fans', self.fans_cb, qos_profile_sensor_data)
        self.cmd_lights_sub = self.create_subscription(Lights, 'platform/mcu/_cmd_lights', self.lights_cb, qos_profile_sensor_data)
        self.cmd_pinout_sub = self.create_subscription(PinoutCommand, 'platform/mcu/_cmd_pinout', self.pinout_cb, qos_profile_sensor_data)

        self.cmd_shutdown_service = self.create_service(Empty, 'platform/mcu/cmd_shutdown', self.cmd_shutdown_cb)
        self.clear_needs_reset_service = self.create_service(Empty, 'platform/mcu/clear_estop_needs_reset', self.clear_needs_reset_cb)

        self.rx = 0
        self.tx = 0

        self.diag_thread = threading.Thread(target=self.update_diag, daemon=True)
        self.diag_thread.start()
        self.read_thread = threading.Thread(target=self.sock_read, daemon=True)
        self.read_thread.start()
        self.send_thread = threading.Thread(target=self.send_bundles, daemon=True)
        #self.send_thread.start()

    def update_diag(self):
        self.last_update = time.time()
        while(1):
            if time.time() - self.last_update >= 1:
                print(f'Rx: {self.rx / 1000} KB/s Tx: {self.tx / 1000} KB/s')
                self.rx = 0
                self.tx = 0
                self.last_update = time.time()

    def battery_cb(self, msg: BatteryState):
        self.send_battery(msg.percentage)

    def display_cb(self, msg: DisplayStatus):
        self.send_display_status(msg.string1, msg.string2)

    def fans_cb(self, msg: Fans):
        self.send_fans(bytes(msg.fans))

    def lights_cb(self, msg: Lights):
        lights_bytes = []
        for rgb in msg.lights:
            lights_bytes.append(bytes([rgb.red, rgb.green, rgb.blue]))
        self.send_lights(lights_bytes)

    def pinout_cb(self, msg: PinoutCommand):
        self.send_pinout_command(msg.rails, msg.outputs)

    def cmd_shutdown_cb(self, req: Empty.Request, res: Empty.Response):
        self.shutting_down = False
        self.send_cmd_shutdown_trigger()
        while not self.shutting_down:
            pass
        print('SHUTDOWN CONFIRMED')
        return res

    def send_cmd_shutdown_trigger(self):
        bundle = Bundle()
        bundle.id = self.CMD_SHUTDOWN_TRIGGER
        bundle.signals.extend([Signal(uint32_value=0xDEADBEEF)])
        self.send(bundle)

    def clear_needs_reset_cb(self, req: Empty.Request, res: Empty.Response):
        self.send_clear_needs_reset()
        return res

    def send_clear_needs_reset(self):
        bundle = Bundle()
        bundle.id = self.CLEAR_NEEDS_RESET
        bundle.signals.extend([Signal(bool_value=True)])
        self.send(bundle)

    def send(self, bundle: Bundle):
        sock.sendto(bundle.SerializeToString(), (MCU_IP, PROTON_MCU_PORT))
        self.tx += bundle.ByteSize()

    def send_battery(self, percent: float):
        bundle = Bundle()
        bundle.id = self.BATTERY_ID
        bundle.signals.extend([
          Signal(
              float_value=percent
          )
        ])
        self.send(bundle)

    def send_fans(self, fans: bytes):
        bundle = Bundle()
        bundle.id = self.CMD_FANS_ID
        bundle.signals.extend([
          Signal(
              bytes_value=fans
          )
        ])
        self.send(bundle)

    def send_lights(self, lights: List[bytes]):
        bundle = Bundle()
        bundle.id = self.CMD_LIGHTS_ID
        for l in lights:
            bundle.signals.extend([
              Signal(
                  bytes_value=l
              )
        ])
        self.send(bundle)

    def send_display_status(self, line1: str, line2: str):
        bundle = Bundle()
        bundle.id = self.DISPLAY_STATUS_ID
        bundle.signals.extend([
          Signal(
              string_value=line1
          ),
          Signal(
              string_value=line2
          )
        ])
        self.send(bundle)

    def send_pinout_command(self, rails: List[bool], outputs: List[int]):
        bundle = Bundle()
        bundle.id = self.PINOUT_COMMAND_ID
        bundle.signals.extend([
          Signal(
              list_bool_value=ListBools(bools=rails)
          ),
          Signal(
              list_uint32_value=ListUint32s(uint32s=outputs)
          )
        ])
        self.send(bundle)

    def send_bundles(self):
        i = 0
        while(True):
            if i % 1000 == 0:
                self.send_display_status()
                self.send_battery()
                self.send_pinout_command()
            if i % 50 == 0:
                self.send_fans()
                self.send_lights()
            time.sleep(0.001)
            i += 1

    def get_header(self) -> Header:
        h = Header()
        h.frame_id = 'a300_proton'
        h.stamp.sec = int(time.time())
        h.stamp.nanosec = time.time_ns()
        return h

    def sock_read(self):
      while(True):
          data, addr = sock.recvfrom(1000)

          bundle = Bundle()
          try:
            Bundle.ParseFromString(bundle, data)
            self.rx += bundle.ByteSize()
            #print(f'Received bundle {hex(bundle.id)} length {bundle.ByteSize()}')
            match bundle.id:
                case self.LOGGER_ID:
                    log = Log()
                    log.stamp.sec = int(time.time())
                    log.stamp.nanosec = time.time_ns()
                    try:
                        log.level = bundle.signals[0].uint32_value
                        log.name = bundle.signals[1].string_value
                        log.msg = bundle.signals[2].string_value
                        log.file = bundle.signals[3].string_value
                        log.function = bundle.signals[4].string_value
                        log.line = bundle.signals[5].uint32_value
                        self.rosout_pub.publish(log)
                    except IndexError:
                        print(bundle)
                case self.POWER_ID:
                    power = Power()
                    power.header = self.get_header()
                    power.measured_voltages.extend(bundle.signals[0].list_float_value.floats)
                    power.measured_currents.extend(bundle.signals[1].list_float_value.floats)
                    self.power_pub.publish(power)
                case self.TEMP_ID:
                    temp = Temperature()
                    temp.header = self.get_header()
                    temp.temperatures.extend(bundle.signals[0].list_float_value.floats)
                    self.temperature_pub.publish(temp)
                case self.STATUS_ID:
                    status = Status()
                    status.header = self.get_header()
                    status.hardware_id = bundle.signals[0].string_value
                    status.firmware_version = bundle.signals[1].string_value
                    status.mcu_uptime.sec = bundle.signals[2].uint32_value
                    status.mcu_uptime.nanosec = bundle.signals[3].uint32_value
                    status.connection_uptime.sec = bundle.signals[4].uint32_value
                    status.connection_uptime.nanosec = bundle.signals[5].uint32_value
                    self.status_pub.publish(status)
                case self.ESTOP_ID:
                    estop = Bool()
                    estop.data = bundle.signals[0].bool_value
                    self.estop_pub.publish(estop)
                case self.STOP_ID:
                    stop = StopStatus()
                    stop.header = self.get_header()
                    stop.external_stop_present = False
                    stop.stop_power_status = True
                    stop.needs_reset = bundle.signals[0].bool_value
                    self.stop_pub.publish(stop)
                case self.PINOUT_STATE_ID:
                    pinout_state = PinoutState()
                    pinout_state.header = self.get_header()
                    pinout_state.rails.extend(bundle.signals[0].list_bool_value.bools)
                    pinout_state.inputs.extend(bundle.signals[1].list_bool_value.bools)
                    pinout_state.outputs.extend(bundle.signals[2].list_bool_value.bools)
                    pinout_state.output_periods.extend(bundle.signals[3].list_uint32_value.uint32s)
                    self.pinout_state_pub.publish(pinout_state)
                case self.ALERTS_ID:
                    alert_string = String()
                    alert_string.data = bundle.signals[0].string_value
                    self.alerts_pub.publish(alert_string)
                case self.CMD_SHUTDOWN_RESPONSE:
                    if bundle.signals[0].uint32_value == 0xDEADBEEF:
                        self.shutting_down = True
          except DecodeError:
              print('Decode Error')



if __name__ == '__main__':
    rclpy.init()
    proton = ProtonProcess()
    rclpy.spin(proton)
    rclpy.shutdown()
